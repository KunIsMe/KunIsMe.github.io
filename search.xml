<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown语法笔记</title>
      <link href="/2021/09/05/Markdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/43645.html"/>
      <url>/2021/09/05/Markdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/43645.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法笔记"><a href="#Markdown语法笔记" class="headerlink" title="Markdown语法笔记"></a>Markdown语法笔记</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>标题层级由<code>#</code>个数区分，数量可为1~6，分别对应一到六级标题。</p><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题复制代码</code></pre><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>在两段文本之间空出至少一行空白行。</p><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">文本一。<!-- 空行 -->文本二。复制代码</code></pre><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>共有4种方式：</p><ul><li><pre class=" language-md"><code class="language-md"><br></code></pre><p>标签换行。</p><ul><li><p>优点：表述清晰。</p></li><li><p>缺点：占行位。</p></li><li><p>语法：</p><pre class=" language-md"><code class="language-md">文本一。<br>文本二。复制代码</code></pre></li></ul></li><li><p>段落换行。</p><ul><li><p>优点：不影响markdown代码美观度。</p></li><li><p>缺点：非正式意义换行。</p></li><li><p>语法：</p><pre class=" language-md"><code class="language-md">文本一。<!-- 空行 -->文本二。复制代码</code></pre></li></ul></li><li><p>句末</p><pre class=" language-md"><code class="language-md">&nbsp;&nbsp;</code></pre><p>换行。</p><ul><li><p>优点：不影响markdown代码美观度。</p></li><li><p>缺点：隐式换行，不够明显。</p></li><li><p>语法：</p><pre class=" language-md"><code class="language-md">文本一。  文本二。复制代码</code></pre></li></ul></li><li><p>句末</p><pre class=" language-md"><code class="language-md">\</code></pre><p>换行。</p><ul><li><p>优点：表述简介，不占行位。</p></li><li><p>缺点：不一定所有markdown解释器都支持。</p></li><li><p>语法：</p></li><li><pre class=" language-md"><code class="language-md">文本一。\文本二。复制代码</code></pre></li></ul></li></ul><blockquote><p>个人喜好段落与段落之间应用空行分隔且不使用<code>&lt;br&gt;</code>。</p></blockquote><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">这是一个_斜体_强调文本。复制代码</code></pre><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">这是一个**粗体**强调文本。复制代码</code></pre><h3 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h3><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">这是一个**_斜体和粗体_**强调文本。复制代码</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">这是一个~~被删除~~的文本。复制代码</code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">> 这是一句引用。> 这是第一段引用。> > 这是第二段引用。> 这是外部引用。> > 这是嵌套引用。> - 在引用中添加其它元素。复制代码</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">1. 项目12. 项目23. 项目31. 项目12. 项目2  1. 子项目1  2. 子项目23. 项目3复制代码</code></pre><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">- 项目1- 项目2- 项目3- 项目1- 项目2  - 子项目1  - 子项目2- 项目3复制代码</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码元素</p><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">`代码元素`复制代码</code></pre><p>代码块</p><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">```语言类型(开始)代码块```(结束)复制代码</code></pre><p>可使用的语言类型有：</p><pre class=" language-md"><code class="language-md">bashclojure，cpp，cs，cssdart，dockerfile, differlanggo，gradle，groovyhaskelljava，javascript，json，juliakotlinlisp，luamakefile，markdown，matlabobjectivecperl，php，pythonr，ruby，rustscala，shell，sql，swifttex，typescriptverilog，vhdlxmlyaml复制代码</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">文本一。____(至少三个)文本二。复制代码</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="直接链接"><a href="#直接链接" class="headerlink" title="直接链接"></a>直接链接</h3><pre class=" language-md"><code class="language-md">链接地址(仅限网址)复制代码</code></pre><h3 id="间接链接"><a href="#间接链接" class="headerlink" title="间接链接"></a>间接链接</h3><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">[超链接显示名](超链接地址 "超链接标题")复制代码</code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">![图片显示名](图片链接 "图片标题")复制代码</code></pre><h2 id="链接图片"><a href="#链接图片" class="headerlink" title="链接图片"></a>链接图片</h2><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">[![图片显示名](图片链接 "图片标题")](超链接地址 "超链接标题")复制代码</code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">|标题1|标题2||-|-||项目1|项目2||项目3|项目4||标题1|标题2||-|-||项目1|项目2||项目3|`代码元素`||一个较长的标题1|一个较长的标题2|一个较长的标题3||:-|:-:|-:||居左对齐|居中对齐|居右对齐||项目1|项目2|项目3||项目4||项目6|复制代码</code></pre><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">这是一句文本[^1]。[^1]:这是对文本的脚注。复制代码</code></pre><h2 id="标题编号"><a href="#标题编号" class="headerlink" title="标题编号"></a>标题编号</h2><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md"># 标题名称 &#123;#标题编号&#125;复制代码</code></pre><blockquote><p>目前没有成功过</p></blockquote><h2 id="链接到标题编号"><a href="#链接到标题编号" class="headerlink" title="链接到标题编号"></a>链接到标题编号</h2><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">[标题名称](#标题编号)复制代码</code></pre><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p><strong>语法：</strong></p><pre class=" language-md"><code class="language-md">- [x] 项目1- [ ] 项目二- [x] 项目三</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML的简单总结</title>
      <link href="/2021/09/03/HTML%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/27896.html"/>
      <url>/2021/09/03/HTML%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/27896.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTML的简单总结"><a href="#HTML的简单总结" class="headerlink" title="HTML的简单总结"></a>HTML的简单总结</h1><h2 id="HTML起手式应该写什么"><a href="#HTML起手式应该写什么" class="headerlink" title="HTML起手式应该写什么"></a>HTML起手式应该写什么</h2><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zh-CN<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viweport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>deviece-wideth, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>复制代码</code></pre><h2 id="常用的表章节的标签有哪些，分别是什么意思"><a href="#常用的表章节的标签有哪些，分别是什么意思" class="headerlink" title="常用的表章节的标签有哪些，分别是什么意思"></a>常用的表章节的标签有哪些，分别是什么意思</h2><ul><li><code>&lt;&lt;h1&gt;&lt;/h1&gt;~&lt;h6&gt;&lt;/h6&gt;</code>: 表示1级至6级的标题，从最大的标题到最小</li><li><code>&lt;section&gt;&lt;/section&gt;</code>: 表示章节块</li><li><code>&lt;article&gt;&lt;/article&gt;</code>: 表示正文</li><li><code>&lt;main&gt;&lt;/main&gt;</code>: 表示主要展示内容</li><li><code>&lt;aside&gt;&lt;/aside&gt;</code>: 表示侧边栏</li><li><code>&lt;header&gt;&lt;/header&gt;</code>: 表示页面的顶部</li><li><code>&lt;footer&gt;&lt;/footer&gt;</code>: 表示页面的底部</li><li><code>&lt;div&gt;&lt;/div&gt;</code>: 在页面中划定一块空间</li><li><code>&lt;p&gt;&lt;/p&gt;</code>：表示段落</li></ul><h2 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h2><h3 id="什么是全局属性"><a href="#什么是全局属性" class="headerlink" title="什么是全局属性"></a>什么是全局属性</h3><p>HTML属性赋予元素意义和语境，全局属性是指任何元素都可以使用的属性。</p><h3 id="常用的全局属性有哪些"><a href="#常用的全局属性有哪些" class="headerlink" title="常用的全局属性有哪些"></a>常用的全局属性有哪些</h3><ul><li><code>class=&quot;&quot;</code>: 标签的类别</li><li><code>id=&quot;&quot;</code>: 标签的id，具有唯一性，但如果出现相同id不会报错</li><li><code>title=&quot;&quot;</code>: 鼠标放上去可以展示标签内的全文</li><li><code>hidden</code>: 可隐藏该标签，但是如果css里有显示的，会覆盖</li><li><code>contentitable</code>: 表示元素是否可以被用户编辑</li><li><code>tabindex=</code>: 可以用tab键选定页面上的标签，从数字最小依次到最大，-1表示不能被选中</li><li><code>style=&quot;&quot;</code>: 标签内的css样式，优先级比外部的样式高</li></ul><h2 id="常用的内容标签有哪些，分别是什么意思"><a href="#常用的内容标签有哪些，分别是什么意思" class="headerlink" title="常用的内容标签有哪些，分别是什么意思"></a>常用的内容标签有哪些，分别是什么意思</h2><ul><li><code>&lt;a&gt;&lt;/a&gt;</code>: 超链接，点击后可以链接到其他页；</li><li><code>&lt;em&gt;&lt;/em&gt;</code>: 主观上的强调，默认字体倾斜</li><li><code>&lt;strong&gt;&lt;/strong&gt;</code>: 客观上的强调，默认字体加粗</li><li><code>&lt;code&gt;&lt;/code&gt;</code>: 展示代码</li><li><code>&lt;pre&gt;&lt;/pre&gt;</code>: 按照原文中的编排格式，以等宽字体的方式表现</li><li><code>&lt;ul&gt;&lt;/ul&gt;</code>: unorder list</li><li><code>&lt;ol&gt;&lt;/ol&gt;</code>: oreder list</li><li><code>&lt;li&gt;&lt;/li&gt;</code>: list item</li><li><code>&lt;dt&gt;&lt;/dt&gt;</code>: describe term</li><li><code>&lt;dl&gt;&lt;/dl&gt;</code>: describe list</li><li><code>&lt;dd&gt;&lt;/dd&gt;</code>: describe data</li><li><code>&lt;hr /&gt;</code>: 分割线</li><li><code>&lt;br /&gt;</code>: 换行</li><li><code>&lt;quote&gt;&lt;/quote&gt;</code>: 表示引用</li><li><code>&lt;blockquote&gt;&lt;/blockquote&gt;</code>：块级的引用</li></ul><h2 id="常用标签的使用方法"><a href="#常用标签的使用方法" class="headerlink" title="常用标签的使用方法"></a>常用标签的使用方法</h2><ol><li><code>&lt;a&gt;&lt;/a&gt;</code>是一个实现超链接的标签，常用的属性有</li></ol><ul><li><code>href</code>: 可以链接网址、文件、以及伪协议。例如</li></ul><pre><code>&lt;a href=&quot;https://juejin.im/editor/posts/5f1d17556fb9a07ea55f25f4&quot;&gt;&lt;/a&gt;&lt;a href=&quot;/c&quot;&gt;&lt;a href=&quot;javascript:;&quot;&lt;/a&gt;复制代码</code></pre><ul><li><code>target</code>: 可以指定跳转页的位置</li></ul><pre><code>&lt;a target=&quot;_blank&quot;&gt;&lt;/a&gt;&lt;a target=&quot;_top&quot;&gt;&lt;/a&gt;&lt;a target=&quot;_self&quot;&gt;&lt;/a&gt;&lt;a target=&quot;_parent&quot;&gt;&lt;/a&gt;复制代码</code></pre><ol><li><code>&lt;img&gt;</code>是一个实现插入图片的标签，常用的属性有</li></ol><ul><li><code>&lt;img src=&quot;&quot;&gt;</code>: 图片的请求位置</li><li><code>&lt;img alt=&quot;&quot;&gt;</code>：图片请求失败的显示</li><li><code>&lt;img width=&quot;&quot;&gt;</code>： 图片的宽度</li><li><code>&lt;img height=&quot;&quot;&gt;</code>： 图片的高度</li></ul><ol><li><code>&lt;table&gt;&lt;/table&gt;</code>是一个实现表格的标签</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thead</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thead</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tbody</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tbody</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tfoot</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tfoot</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>复制代码</code></pre><ul><li><code>borde-collapse</code>和<code>border-spacing</code>属性可以控制表格边框的分合及相邻边框的间距</li></ul><ol><li><code>&lt;form&gt;&lt;/form&gt;</code>是一个实现表单提交的标签，常用的属性有</li></ol><ul><li><code>&lt;form action=&quot;&quot;&gt;</code>：提交的URL</li><li><code>&lt;form target=&quot;&quot;&gt;</code>: 提交后跳转的位置</li><li><code>&lt;form method=&quot;&quot;&gt;</code>: 表单提交的方式，有GET、POST</li><li><code>&lt;form name=&quot;&quot;&gt;</code>: H4不推荐，应使用<code>id</code>；H5中使用，应确保表单<code>name</code>的唯一性</li></ul><ol><li><code>&lt;input&gt;</code>是一个实现表单输入框标签，常用的属性有</li></ol><ul><li><code>&lt;input type=“text”&gt;</code>：文本输入框</li><li><code>&lt;input type=&quot;passowrd&quot;&gt;</code>: 密码输出框</li><li><code>&lt;input type=&quot;radio&quot;&gt;</code>：单选框</li><li><code>&lt;input type=&quot;checkbox&quot;&gt;</code>: 多选框</li><li><code>&lt;input type=&quot;submit&quot;&gt;</code>: 表单提交与<code>&lt;button&gt;&lt;/button&gt;</code>相比，两者都可以完成表单提交，但<code>&lt;button&gt;</code>之间还是添加其他的标签,而<code>&lt;input type=&quot;submit&quot;&gt;</code>却不行</li><li><code>&lt;input type=&quot;file&quot;&gt;</code>: 文件提交</li><li><code>&lt;input type=&quot;button value=&quot;&quot;&gt;</code>: 没有默认行为，上面显示<code>value</code>的值</li></ul><ol><li><code>&lt;textarea&gt;&lt;/textarea&gt;</code>是一个实现多行文本框输入的标签，常用的属性有</li></ol><ul><li><code>&lt;textarea name=&quot;&quot;&gt;</code>: 表单提交时文本框的名称</li><li><code>&lt;textarea row=&quot;&quot; cols=&quot;&quot;&gt;</code>: 确定文本框的行和列的准确值</li><li><code>&lt;textarea maxlength=&quot;&quot; minlength=&quot;&quot;&gt;</code>: 允许用户输入的最大字符长度和最小字符长度</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒模型</title>
      <link href="/2021/08/20/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/53481.html"/>
      <url>/2021/08/20/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/53481.html</url>
      
        <content type="html"><![CDATA[<h1 id="CSS盒模型详解"><a href="#CSS盒模型详解" class="headerlink" title="CSS盒模型详解"></a>CSS盒模型详解</h1><h5 id="可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着，这就是所谓的盒模型。"><a href="#可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着，这就是所谓的盒模型。" class="headerlink" title="可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着，这就是所谓的盒模型。"></a>可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着，这就是所谓的盒模型。</h5><h4 id="盒模型分为IE盒模型和W3C标准盒模型。"><a href="#盒模型分为IE盒模型和W3C标准盒模型。" class="headerlink" title="盒模型分为IE盒模型和W3C标准盒模型。"></a>盒模型分为IE盒模型和W3C标准盒模型。</h4><h2 id="IE盒模型和W3C标准盒模型的-区别-是什么？"><a href="#IE盒模型和W3C标准盒模型的-区别-是什么？" class="headerlink" title="IE盒模型和W3C标准盒模型的***区别***是什么？"></a>IE盒模型和W3C标准盒模型的***区别***是什么？</h2><h4 id="1-W3C-标准盒模型："><a href="#1-W3C-标准盒模型：" class="headerlink" title="1. W3C 标准盒模型："></a>1. W3C 标准盒模型：</h4><h4 id="属性width-height只包含内容content，不包含border和padding。"><a href="#属性width-height只包含内容content，不包含border和padding。" class="headerlink" title="属性width,height只包含内容content，不包含border和padding。"></a><em>属性width,height只包含内容content，不包含border和padding。</em></h4><h4 id="2-IE-盒模型："><a href="#2-IE-盒模型：" class="headerlink" title="2. IE 盒模型："></a>2. IE 盒模型：</h4><h4 id="属性width-height包含border和padding，指的是content-padding-border。"><a href="#属性width-height包含border和padding，指的是content-padding-border。" class="headerlink" title="属性width,height包含border和padding，指的是content+padding+border。"></a><em>属性width,height包含border和padding，指的是content+padding+border。</em></h4><h4 id="在ie8-浏览器中使用哪个盒模型可以由box-sizing-CSS新增的属性-控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6-7-8中DOCTYPE缺失会触发IE模式。在当前W3C标准中盒模型是可以通过box-sizing自由的进行切换的。"><a href="#在ie8-浏览器中使用哪个盒模型可以由box-sizing-CSS新增的属性-控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6-7-8中DOCTYPE缺失会触发IE模式。在当前W3C标准中盒模型是可以通过box-sizing自由的进行切换的。" class="headerlink" title="在ie8+浏览器中使用哪个盒模型可以由box-sizing(CSS新增的属性)控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6,7,8中DOCTYPE缺失会触发IE模式。在当前W3C标准中盒模型是可以通过box-sizing自由的进行切换的。"></a>在ie8+浏览器中使用哪个盒模型可以由<strong>box-sizing</strong>(CSS新增的属性)控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6,7,8中DOCTYPE缺失会触发IE模式。在当前W3C标准中盒模型是可以通过box-sizing自由的进行切换的。</h4><h4 id="content-box（标准盒模型）"><a href="#content-box（标准盒模型）" class="headerlink" title="content-box（标准盒模型）"></a>content-box（标准盒模型）</h4><h4 id="width-内容的宽度"><a href="#width-内容的宽度" class="headerlink" title="width = 内容的宽度"></a>width = 内容的宽度</h4><h4 id="height-内容的高度"><a href="#height-内容的高度" class="headerlink" title="height = 内容的高度"></a>height = 内容的高度</h4><h4 id="border-box（IE盒模型）"><a href="#border-box（IE盒模型）" class="headerlink" title="border-box（IE盒模型）"></a>border-box（IE盒模型）</h4><h4 id="width-border-padding-内容的宽度"><a href="#width-border-padding-内容的宽度" class="headerlink" title="width = border + padding + 内容的宽度"></a>width = border + padding + 内容的宽度</h4><h4 id="height-border-padding-内容的高度"><a href="#height-border-padding-内容的高度" class="headerlink" title="height = border + padding + 内容的高度"></a>height = border + padding + 内容的高度</h4><h5 id="谷歌浏览器，按下F12，然后把右边栏的滚动条拉到最下面你就会看到一个东西："><a href="#谷歌浏览器，按下F12，然后把右边栏的滚动条拉到最下面你就会看到一个东西：" class="headerlink" title="谷歌浏览器，按下F12，然后把右边栏的滚动条拉到最下面你就会看到一个东西："></a>谷歌浏览器，按下F12，然后把右边栏的滚动条拉到最下面你就会看到一个东西：</h5><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/9cb491d4bd5d326aeb16632280411283~tplv-t2oaga2asx-watermark.awebp" alt="这里写图片描述">这里写图片描述</p><h5 id="通过代码来对其进行理解，更直观，如下"><a href="#通过代码来对其进行理解，更直观，如下" class="headerlink" title="通过代码来对其进行理解，更直观，如下"></a>通过代码来对其进行理解，更直观，如下</h5><pre><code>.box&#123;        width:200px;        height:200px;        background-color:pink;&#125;复制代码</code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/1c68d2c4a3a1295233a9ea1b92174aca~tplv-t2oaga2asx-watermark.awebp" alt="这里写图片描述">这里写图片描述</p><h5 id="此时，盒子大小就是content的大小。"><a href="#此时，盒子大小就是content的大小。" class="headerlink" title="此时，盒子大小就是content的大小。"></a>此时，盒子大小就是content的大小。</h5><pre><code>.box&#123;        width:200px;        height:200px;        background-color:pink;        padding:20px;&#125;复制代码</code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/a5b6877351a949f16cc99dc27dadfd50~tplv-t2oaga2asx-watermark.awebp" alt="这里写图片描述">这里写图片描述</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/a6a8e2bd6929e6b1a420b711b6504259~tplv-t2oaga2asx-watermark.awebp" alt="这里写图片描述">这里写图片描述</p><h5 id="此时，盒子的长宽变成了240x240，显然，padding是能够改变盒子的大小的，这时盒子大小就等于content-padding。"><a href="#此时，盒子的长宽变成了240x240，显然，padding是能够改变盒子的大小的，这时盒子大小就等于content-padding。" class="headerlink" title="此时，盒子的长宽变成了240x240，显然，padding是能够改变盒子的大小的，这时盒子大小就等于content+padding。"></a>此时，盒子的长宽变成了240x240，显然，padding是能够改变盒子的大小的，这时盒子大小就等于content+padding。</h5><pre><code>.box&#123;        width:200px;        height:200px;        background-color:pink;        padding:20px;        border:10px solid black;&#125;复制代码</code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/46f5cf238d791eec27032c53b19a4083~tplv-t2oaga2asx-watermark.awebp" alt="这里写图片描述">这里写图片描述</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/cfff88aff482f7dd89d60d7498695450~tplv-t2oaga2asx-watermark.awebp" alt="这里写图片描述">这里写图片描述</p><h5 id="此时，盒子的长宽变成了260x260，所以这时盒子大小就等于content-padding-border。"><a href="#此时，盒子的长宽变成了260x260，所以这时盒子大小就等于content-padding-border。" class="headerlink" title="此时，盒子的长宽变成了260x260，所以这时盒子大小就等于content+padding+border。"></a>此时，盒子的长宽变成了260x260，所以这时盒子大小就等于content+padding+border。</h5><pre><code>.box&#123;        width:200px;        height:200px;        background-color:pink;        padding:20px;        border:10px solid black;        margin-bottom:10px;&#125;.box1&#123;        width: 100px;        height: 100px;        background: green;&#125;复制代码</code></pre><h5 id="效果图如下："><a href="#效果图如下：" class="headerlink" title="效果图如下："></a>效果图如下：</h5><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/75d4b04ce272a657a3a9cbf317c4393e~tplv-t2oaga2asx-watermark.awebp" alt="这里写图片描述">这里写图片描述</p><h5 id="此时，盒子的长宽仍为260x260，即盒子的大小并未发生变化。"><a href="#此时，盒子的长宽仍为260x260，即盒子的大小并未发生变化。" class="headerlink" title="此时，盒子的长宽仍为260x260，即盒子的大小并未发生变化。"></a>此时，盒子的长宽仍为260x260，即盒子的大小并未发生变化。</h5><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/64c02f116f554e763086f59332a0220f~tplv-t2oaga2asx-watermark.awebp" alt="这里写图片描述">这里写图片描述</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/5a8531db3705b56d9c07dc480eb1a49c~tplv-t2oaga2asx-watermark.awebp" alt="这里写图片描述">这里写图片描述</p><h5 id="可以看到，盒子的底部产生了10px的空白。"><a href="#可以看到，盒子的底部产生了10px的空白。" class="headerlink" title="可以看到，盒子的底部产生了10px的空白。"></a>可以看到，盒子的底部产生了10px的空白。</h5><h4 id="所以说，盒子的大小为content-padding-border即内容的-width-内边距的再加上边框，而不加上margin。很多时候，我们会错误地把margin算入，若那样的话，上面这种情形盒子的大小应该是260x270，但实际情况并不是这样的。"><a href="#所以说，盒子的大小为content-padding-border即内容的-width-内边距的再加上边框，而不加上margin。很多时候，我们会错误地把margin算入，若那样的话，上面这种情形盒子的大小应该是260x270，但实际情况并不是这样的。" class="headerlink" title="所以说，盒子的大小为content+padding+border即内容的(width)+内边距的再加上边框，而不加上margin。很多时候，我们会错误地把margin算入，若那样的话，上面这种情形盒子的大小应该是260x270，但实际情况并不是这样的。"></a>所以说，盒子的大小为content+padding+border即内容的(width)+内边距的再加上边框，而不加上margin。很多时候，我们会错误地把margin算入，若那样的话，上面这种情形盒子的大小应该是260x270，但实际情况并不是这样的。</h4><h4 id="css的盒模型由content-内容-、padding-内边距-、border-边框-、margin-外边距-组成。但盒子的大小由content-padding-border这几部分决定，把margin算进去的那是盒子占据的位置，而不是盒子的大小！"><a href="#css的盒模型由content-内容-、padding-内边距-、border-边框-、margin-外边距-组成。但盒子的大小由content-padding-border这几部分决定，把margin算进去的那是盒子占据的位置，而不是盒子的大小！" class="headerlink" title="css的盒模型由content(内容)、padding(内边距)、border(边框)、margin(外边距)组成。但盒子的大小由content+padding+border这几部分决定，把margin算进去的那是盒子占据的位置，而不是盒子的大小！"></a>css的盒模型由content(内容)、padding(内边距)、border(边框)、margin(外边距)组成。但盒子的大小由content+padding+border这几部分决定，<strong>把margin算进去的那是盒子占据的位置，而不是盒子的大小！</strong></h4><h5 id="我们可以试着给上面的粉色方块设置box-sizing属性为border-box发现，会发现：无论我们怎么改border和padding盒子大小始终是定义的width和height。如下"><a href="#我们可以试着给上面的粉色方块设置box-sizing属性为border-box发现，会发现：无论我们怎么改border和padding盒子大小始终是定义的width和height。如下" class="headerlink" title="我们可以试着给上面的粉色方块设置box-sizing属性为border-box发现，会发现：无论我们怎么改border和padding盒子大小始终是定义的width和height。如下"></a>我们可以试着给上面的粉色方块设置box-sizing属性为border-box发现，会发现：无论我们怎么改border和padding盒子大小始终是定义的width和height。如下</h5><pre><code>.box&#123;        width:200px;        height:200px;        background-color:pink;        box-sizing:border-box;        padding:20px;&#125;复制代码</code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/1/6f8ebef46390a17b9d96921c472f537d~tplv-t2oaga2asx-watermark.awebp" alt="这里写图片描述">这里写图片描述</p><h4 id="我们在编写页面代码时应尽量使用标准的W3C模型-需在页面中声明DOCTYPE类型-，这样可以避免多个浏览器对同一页面的不兼容。"><a href="#我们在编写页面代码时应尽量使用标准的W3C模型-需在页面中声明DOCTYPE类型-，这样可以避免多个浏览器对同一页面的不兼容。" class="headerlink" title="我们在编写页面代码时应尽量使用标准的W3C模型(需在页面中声明DOCTYPE类型)，这样可以避免多个浏览器对同一页面的不兼容。"></a>我们在编写页面代码时应尽量使用标准的W3C模型(需在页面中声明DOCTYPE类型)，这样可以避免多个浏览器对同一页面的不兼容。</h4><h4 id="因为若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒子模型，FireFox等会将其解释为W3C盒子模型；若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。"><a href="#因为若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒子模型，FireFox等会将其解释为W3C盒子模型；若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。" class="headerlink" title="因为若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒子模型，FireFox等会将其解释为W3C盒子模型；若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。"></a>因为若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒子模型，FireFox等会将其解释为W3C盒子模型；<strong>若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。</strong></h4>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3setup和生命周期函数</title>
      <link href="/2021/08/15/Vue3%20setup%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/16107.html"/>
      <url>/2021/08/15/Vue3%20setup%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/16107.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue3setup和生命周期"><a href="#vue3setup和生命周期" class="headerlink" title="vue3setup和生命周期"></a>vue3setup和生命周期</h1><h2 id="setup函数的特性"><a href="#setup函数的特性" class="headerlink" title="setup函数的特性"></a>setup函数的特性</h2><blockquote><ul><li>使用Composition API 的入口</li><li>在beforeCreate之前调用</li><li>在setup中没有this</li><li>返回对象中的属性刻在模板中使用</li><li>setup函数是处于生命周期函数 beforeCreate 和 Created 两个钩子函数之间的函数 也就说在 setup函数中是无法 使用 data 和 methods 中的数据和方法的</li><li>setup函数是 Composition API（组合API）的入口</li><li>在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用</li></ul></blockquote><h2 id="setup定义变量及方法ref和reactive"><a href="#setup定义变量及方法ref和reactive" class="headerlink" title="setup定义变量及方法ref和reactive"></a>setup定义变量及方法ref和reactive</h2><pre><code>ref`接受一个内部值并返回一个响应式且可变的 `ref` 对象。`ref` 对象具有指向内部值的单个 `property .value</code></pre><p><code>reactive</code>是返回对象的响应式副本</p><blockquote><p>1、简单数据类型（String、Number等）推荐使用ref</p><p>引入： import { ref } from ‘vue’ 使用：let count = ref(1); 后面想改变或获取值，通过count.value进行</p><p>2、复杂数据类型（Array、Object）推荐使用reactive</p><p>引入： import { reactive } from ‘vue’ 使用： let arr = reactive({ age：18 })，传入一个对象，vue会封装成Proxy对象，使用里面的方法实现响应式数据</p></blockquote><blockquote><p>注意：如果不需要做响应式的数据，比如从接口获取的数据，直接声明变量存放即可，不需要调用ref或者reactive</p></blockquote><p>上代码：</p><pre><code>&lt;template&gt;  &lt;div class=&quot;word&quot;&gt;    &lt;div&gt;ref:&#123;&#123; count &#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;addRefFun&quot;&gt;点击ref自增&lt;/button&gt;    &lt;div&gt;reactive:&#123;&#123; state.reactivelist &#125;&#125;&lt;/div&gt;    &lt;div&gt;reactive数组:&#123;&#123; state.arr &#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;addReactiveFun&quot;&gt;点击reactive自增&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; reactive, ref, toRef &#125; from &quot;vue&quot;;export default &#123;  components: &#123;&#125;,  setup() &#123;    const count = ref(1);    const state = reactive(&#123;      reactivelist: 1,      arr: [1, 2],    &#125;);    const addRefFun = () =&gt; &#123;      count.value++;    &#125;;    const addReactiveFun = () =&gt; &#123;      state.reactivelist++;      state.arr.push(3, 4, 5);    &#125;;    let age = toRef(state, &quot;age&quot;);    state.age = 1;    console.log(state);    return &#123;      count,      state,      age,      addRefFun,      addReactiveFun,    &#125;;  &#125;,&#125;;&lt;/script&gt;复制代码</code></pre><p>说了那么多，其实我们一直都在做同一件事情，那就是双向数据绑定。vue一共提供了两种数据响应式监听，这就有点React Hooks的味道了。ref 函数传入一个值作为参数，返回一个基于该值的响应式Ref对象，该对象中的值一旦被改变和访问，都会被跟踪到，就像我们改写后的示例代码一样，通过修改 count.value 的值，可以触发模板的重新渲染，显示最新的值。 其实，除了 ref 函数，Vue3.0中还提供了另外一个可以创建响应式对象的函数，那就是 reactive 函数。</p><p>为什么要同时提供这两个API呢？下面来说一说。</p><h5 id="1-是为了适应不同的写法的人群"><a href="#1-是为了适应不同的写法的人群" class="headerlink" title="1.是为了适应不同的写法的人群"></a>1.是为了适应不同的写法的人群</h5><p>有人喜欢这种的写法：</p><pre><code>const a = 1const b = 2复制代码</code></pre><p>也有人喜欢这种的写法：</p><pre><code>const field = &#123;  a : 1,  b : 1    &#125;复制代码</code></pre><p>怎么样的写法，看自己跟人。这两种风格的代码都是没有问题。关键在于个人的偏好。</p><h5 id="2-ref只可以监听简单的数据，而reactive可以监听所有的数据"><a href="#2-ref只可以监听简单的数据，而reactive可以监听所有的数据" class="headerlink" title="2.ref只可以监听简单的数据，而reactive可以监听所有的数据"></a>2.ref只可以监听简单的数据，而reactive可以监听所有的数据</h5><p>ref这种写法简单，但也有弊端，经过尝试，我发现他只能监听一些如数字、字符串、布尔之类的简单数据。而一些复杂的数据或者是对象我们可以用reactive来实现</p><h5 id="3-使用的方式不一样"><a href="#3-使用的方式不一样" class="headerlink" title="3.使用的方式不一样"></a>3.使用的方式不一样</h5><p>1、ref修改数据需要使用这样count.value=xxx的形式，而reactive只需要state.reactiveField=值这样来使用</p><p>2、第二点体现在template中引用时候为reactiveField，不需要state，也就是说我reactive对象里面字段是应该直接使用的</p><p>3、体现在reactive在return时候需要toRefs来转换成响应式对象</p><h4 id="ref和reactive区别"><a href="#ref和reactive区别" class="headerlink" title="ref和reactive区别:"></a>ref和reactive区别:</h4><ol><li>如果在template里使用的是ref类型的数据, 那么Vue会自动帮我们添加.value</li><li>如果在template里使用的是reactive类型的数据, 那么Vue不会自动帮我们添加.value</li></ol><p>我门可以通过isRef / isReactive 方法来判断数据到底是ref还是reactive</p><h2 id="setup声明周期"><a href="#setup声明周期" class="headerlink" title="setup声明周期"></a>setup声明周期</h2><p>从’vue’中引入的生命周期函数,这些生命周期钩子注册函数只能在setup()期间同步使用 因为它们依赖于内部的全局状态来定位当前组件实例(正在调用setup()的组件实例),不在当前组件下调用这些函数会抛出一个错误。 即可以从其他文件引入使用了生命周期的函数等,放在setup中执行</p><p>和外部的生命周期函数相比,会优先指向setUp内的生命周期函数,再去执行外部的生命周期函数</p><table><thead><tr><th>vue2.0</th><th>vue3.0</th></tr></thead><tbody><tr><td>beforeCreate</td><td>setup</td></tr><tr><td>beforeCreate</td><td>setup</td></tr><tr><td>created</td><td>setup</td></tr><tr><td>beforeMount(挂载前)</td><td>onBeforeMount</td></tr><tr><td>mounted(挂载后)</td><td>onMounted</td></tr><tr><td>beforeUpdate(数据更新前)</td><td>onBeforeUpdate</td></tr><tr><td>updated(数据更新后)</td><td>onUpdated</td></tr><tr><td>beforeDestroy(销毁前)</td><td>onBeforeUnmount</td></tr><tr><td>destroyed(销毁后)</td><td>onUnmounted</td></tr></tbody></table><pre><code>&lt;script&gt;import &#123;  onBeforeMount,  onMounted,  onBeforeUpdate,  onUpdated,  onBeforeUnmount,  onUnmounted,  onRenderTracked,  onRenderTriggered,&#125; from &quot;vue&quot;;export default &#123;  components: &#123;&#125;,  data() &#123;    return &#123;&#125;;  &#125;,  setup() &#123;    // setup里面存着两个生命周期创建前和创建后    // beforeCreate    // created    onBeforeMount(() =&gt; &#123;      console.log(&quot;onBefore   ====&gt;  vue2.0 x beforemount&quot;);    &#125;);    onMounted(() =&gt; &#123;      console.log(&quot;onMounted  ====&gt;  vue2.0 x mount&quot;);    &#125;);    onBeforeUpdate(() =&gt; &#123;      console.log(&quot;onBeforeUpdate  ====&gt;  vue2.0 x beforeUpdate&quot;);    &#125;);    onUpdated(() =&gt; &#123;      console.log(&quot;onUpdated  ====&gt;  vue2.0 x update&quot;);    &#125;);    onBeforeUnmount(() =&gt; &#123;      //在卸载组件实例之前调用。在这个阶段，实例仍然是完全正常的。      console.log(&quot;onBeforeUnmount ====&gt;  vue2.0 x beforeDestroy&quot;);    &#125;);    onUnmounted(() =&gt; &#123;      //卸载组件实例后调用,调用此钩子时,组件实例的所有指令都被解除绑定,所有事件侦听器都被移除,所有子组件实例被卸载。      console.log(&quot;onUnmounted ====&gt;  vue2.0 x destroyed&quot;);    &#125;);    // 新增两个生命周期函数    //每次渲染后重新收集响应式依赖    onRenderTracked((&#123; key, target, type &#125;) =&gt; &#123;      // 跟踪虚拟DOM重新渲染时调用,钩子接收debugger event作为参数,此事件告诉你哪个操作跟踪了组件以及该操作的目标对象和键。      // type:set/get操作      // key:追踪的键      // target:重新渲染后的键      console.log(&quot;onRenderTracked&quot;);    &#125;);    //每次触发页面重新渲染时自动执行    onRenderTriggered((&#123; key, target, type &#125;) =&gt; &#123;      //当虚拟DOM重新渲染被触发时调用,和renderTracked类似,接收debugger event作为参数,      // 此事件告诉你是什么操作触发了重新渲染,以及该操作的目标对象和键      console.log(&quot;onRenderTriggered&quot;);    &#125;);    return &#123;&#125;;  &#125;,&#125;;&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
